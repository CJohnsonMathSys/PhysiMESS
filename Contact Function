/* ****************************************************************************
   Cell velocity correction due to "fibres"                                       
   **************************************************************************** */
void CoupledModel::cell_fibres_interaction(Cell& cell)
{
  vector<double> fibre_adhesion, fibre_repulsion;
  fibre_adhesion.resize(params.dimension);
  fibre_adhesion.clear();
  fibre_repulsion.resize(params.dimension);
  fibre_repulsion.clear();
  unsigned int n_fibres = cell.contact_fibres.size();

  // additional model parameters
  double cell_velocity_max = 10.;// [micron/s]
  double p_exponent = 1.; 
  double q_exponent = 1.;
  
  // compute current cell velocity
  double cell_velocity = 0.;
  for (unsigned int j=0; j<params.dimension; j++) {
    cell_velocity += cell.polarity[j]*cell.polarity[j];
  }
  cell_velocity = sqrt(cell_velocity);

  // for all the fibres in contact with the cell
  for(unsigned int k=0; k<n_fibres; k++) {
  
    // velocity_dot_direction = (cell.vel,fibre.direction)
    double velocity_dot_direction = 0.;  
    for (unsigned int j=0; j<params.dimension; j++) {
      velocity_dot_direction += cell.contact_fibres[k]->direction[j]*cell.polarity[j];
    }

    for (unsigned int j=0; j<params.dimension; j++) {
    
      double xi = fabs(velocity_dot_direction)/(cell_velocity+1e-8); 
 
      double xip = pow(xi,p_exponent);

      // fibre_adhesion = alpha*|(v,f)| f  
      fibre_adhesion[j] += params.vel_adhesion * xip * (1 - cell_velocity/cell_velocity_max) * (cell.contact_fibres[k]->direction[j]);						   

      double xiq = pow((1-xi*xi),q_exponent);

      // fibre_repulsion = -beta*(1-|(v,f)|^2/|v|^2)*v
      fibre_repulsion[j] += -params.vel_contact * xiq * (cell.vel[j]);      
    }
    
  }

  // add force
  for (unsigned int j=0; j<params.dimension; j++) {
    cell.force[j] += (fibre_adhesion[j] + fibre_repulsion[j]);
  }
  
}

    cell.vel[0] = (cell.force[0] + box_muller(0,vf))/friction;
    cell.vel[1] = (cell.force[1] + box_muller(0,vf))/friction;
    cell.vel[2] = (cell.force[2] + box_muller(0,vf))/friction;
    
    
double CoupledModel::box_muller(const double m, const double s)	
{				        
  double w, y1;
  double x1, x2;
  static double y2;
  static int use_last = 0;
  if (use_last)	{	        /* use value from previous call */
    y1 = y2;
    use_last = 0;
  } else {
    do {
      x1 = 2.0 * this->aleatorio() - 1.0;
      x2 = 2.0 * this->aleatorio() - 1.0;
      w = x1 * x1 + x2 * x2;
    } while ( w >= 1.0 );
    
    w = sqrt( (-2.0 * log( w ) ) / w );
    y1 = x1 * w;
    y2 = x2 * w;
    use_last = 1;
  }
  
  return( m + y1 * s );
}


double CoupledModel::aleatorio()
{
  double random_value = rand();
  return (random_value/RAND_MAX);
}



